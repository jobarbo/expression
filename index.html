<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Three.js Pixelation Effect</title>
		<style>
			body {
				display: flex;
				justify-content: center;
				align-items: center;
				flex-direction: column;
				height: 100vh;
				margin: 0;
				background-color: #1a1a1a;
				font-family: Arial, sans-serif;
				overflow: hidden;
				color: white;
			}
			#textContainer {
				width: 100%;
				height: 100vh;
				position: relative;
				overflow: hidden;
				display: flex;
				justify-content: center;
				align-items: center;
			}
			canvas {
				display: block;
				position: absolute;
				top: 0;
				left: 0;
			}
			.info {
				position: absolute;
				bottom: 20px;
				color: rgba(255, 255, 255, 0.7);
				font-size: 1rem;
				z-index: 10;
				text-align: center;
				width: 100%;
				padding: 10px;
				background-color: rgba(0, 0, 0, 0.2);
				border-radius: 5px;
				backdrop-filter: blur(4px);
				-webkit-backdrop-filter: blur(4px);
				transition: opacity 0.3s ease;
			}
			.title {
				position: absolute;
				top: 20px;
				left: 20px;
				font-size: 1.2rem;
				font-weight: bold;
				z-index: 10;
				opacity: 0.8;
			}
		</style>
	</head>
	<body>
		<div id="textContainer"></div>
		<div class="info">Move your mouse over the text to see pixelation effects</div>
		<div class="title">EXPR</div>

		<script type="module">
			// Import Three.js from CDN
			import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js";

			// Setup variables
			let easeFactor = 0.02;
			let scene, camera, renderer, planeMesh;
			let mousePosition = {x: 0.5, y: 0.5};
			let targetMousePosition = {x: 0.5, y: 0.5};
			let prevPosition = {x: 0.5, y: 0.5};
			let mouseSpeed = 0;
			const textContainer = document.getElementById("textContainer");

			// Shader code
			const vertexShader = `
				varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				}
			`;

			const fragmentShader = `
				varying vec2 vUv;
				uniform sampler2D u_texture;
				uniform vec2 u_mouse;
				uniform vec2 u_prevMouse;
				uniform float u_mouseSpeed;
				uniform float u_time;

				void main() {
					// Default to using the original uv coordinates (unpixelated)
					vec2 uv = vUv;

					// Calculate distance from current pixel to mouse position
					float distToMouse = distance(vUv, u_mouse);

					// Only pixelate when mouse is very close
					if (distToMouse < 0.2) {
						// Calculate pixel size - very fine pixels for subtle effect
						float pixelSize = mix(200.0, 200.0, smoothstep(0.2, 0.0, distToMouse));

						// Create the pixelated grid effect only near the mouse
						vec2 gridUV = floor(vUv * pixelSize) / pixelSize;

						// Apply the minimal pixelation
						uv = gridUV;

						// Almost imperceptible displacement
						if (distToMouse < 0.05) {
							vec2 mouseDirection = u_mouse - u_prevMouse;
							uv -= mouseDirection * 0.01 * smoothstep(0.05, 0.0, distToMouse);
						}

						// Very smooth transition at the edges
						if (distToMouse > 0.15 && distToMouse < 0.2) {
							float mixFactor = smoothstep(0.2, 0.15, distToMouse);
							uv = mix(vUv, uv, mixFactor);
						}
					}

					// Sample texture with our final UV coordinates
					vec4 color = texture2D(u_texture, uv);

					gl_FragColor = color;
				}
			`;

			// Function to create canvas texture with text
			function createTextTexture(text, font, size, color, fontWeight = "bold") {
				const canvas = document.createElement("canvas");
				const ctx = canvas.getContext("2d");

				// Make canvas size responsive to window size
				const canvasWidth = Math.max(window.innerWidth, window.innerHeight) * 2;
				const canvasHeight = canvasWidth * (window.innerHeight / window.innerWidth);

				canvas.width = canvasWidth;
				canvas.height = canvasHeight;

				// Background color
				ctx.fillStyle = "#1a1a1a";
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// Calculate font size - use larger font for better visibility
				const fontSize = size || Math.floor(canvasWidth / 6);

				// Text styling - use bold, clean font
				ctx.fillStyle = color || "#ffffff";
				ctx.font = `${fontWeight} ${fontSize}px sans-serif`;
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";

				// Enable anti-aliasing
				ctx.imageSmoothingEnabled = true;
				ctx.imageSmoothingQuality = "high";

				// Measure text to properly scale it
				const textMetrics = ctx.measureText(text);
				const textWidth = textMetrics.width;

				// Calculate scale to fit the text width into the canvas
				const scaleFactor = Math.min(1, (canvasWidth * 0.8) / textWidth);
				const aspectCorrection = canvasWidth / canvasHeight;

				// Set transformation matrix for centering and scaling
				ctx.setTransform(scaleFactor, 0, 0, scaleFactor / aspectCorrection, canvasWidth / 2, canvasHeight / 2);

				// Draw text with clean edges
				ctx.fillText(text, 0, 0);

				// Create a Three.js texture from the canvas
				return new THREE.CanvasTexture(canvas);
			}

			// Initialize the 3D scene
			function initializeScene(texture) {
				scene = new THREE.Scene();

				// Use orthographic camera for 2D-style rendering
				const aspectRatio = window.innerWidth / window.innerHeight;
				camera = new THREE.OrthographicCamera(-1, 1, 1 / aspectRatio, -1 / aspectRatio, 0.1, 1000);
				camera.position.z = 1;

				// Create shader uniforms
				let shaderUniforms = {
					u_mouse: {type: "v2", value: new THREE.Vector2()},
					u_prevMouse: {type: "v2", value: new THREE.Vector2()},
					u_texture: {type: "t", value: texture},
					u_mouseSpeed: {type: "f", value: 0.0},
					u_time: {type: "f", value: 0.0},
				};

				// Create a plane with the shader material
				planeMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(2, 2),
					new THREE.ShaderMaterial({
						uniforms: shaderUniforms,
						vertexShader,
						fragmentShader,
					})
				);

				scene.add(planeMesh);

				// Setup renderer with better quality
				renderer = new THREE.WebGLRenderer({
					antialias: true,
					alpha: true,
				});
				renderer.setClearColor(0x1a1a1a, 1);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for performance

				// Add renderer to the container
				textContainer.appendChild(renderer.domElement);
			}

			// Initialize the scene with our text texture
			initializeScene(createTextTexture("EXPRESSION", "sans-serif", null, "#ffffff", "bold"));

			// Animation loop
			let startTime = Date.now();
			function animateScene() {
				requestAnimationFrame(animateScene);

				// Store current position for velocity calculation
				const oldX = mousePosition.x;
				const oldY = mousePosition.y;

				// Smooth mouse movement with easing
				mousePosition.x += (targetMousePosition.x - mousePosition.x) * easeFactor;
				mousePosition.y += (targetMousePosition.y - mousePosition.y) * easeFactor;

				// Calculate mouse speed (distance moved since last frame)
				const dx = mousePosition.x - oldX;
				const dy = mousePosition.y - oldY;
				mouseSpeed = Math.sqrt(dx * dx + dy * dy);

				// Gradually decay mouse speed
				mouseSpeed = Math.min(1.0, mouseSpeed * 15.0);

				// Update shader uniforms with mouse positions and speed
				planeMesh.material.uniforms.u_mouse.value.set(mousePosition.x, 1.0 - mousePosition.y);

				planeMesh.material.uniforms.u_prevMouse.value.set(prevPosition.x, 1.0 - prevPosition.y);

				planeMesh.material.uniforms.u_mouseSpeed.value = mouseSpeed;

				// Update time uniform for animations
				planeMesh.material.uniforms.u_time.value = (Date.now() - startTime) / 1000;

				// Update previous position for motion trail
				prevPosition = {x: oldX, y: oldY};

				// Render the scene
				renderer.render(scene, camera);
			}

			// Start the animation loop
			animateScene();

			// Event handlers for mouse movement
			textContainer.addEventListener("mousemove", handleMouseMove);
			textContainer.addEventListener("mouseenter", handleMouseEnter);
			textContainer.addEventListener("mouseleave", handleMouseLeave);

			function handleMouseMove(event) {
				easeFactor = 0.035; // Medium speed tracking
				let rect = textContainer.getBoundingClientRect();
				prevPosition = {...mousePosition};

				targetMousePosition.x = (event.clientX - rect.left) / rect.width;
				targetMousePosition.y = (event.clientY - rect.top) / rect.height;
			}

			function handleMouseEnter(event) {
				easeFactor = 0.1; // Fast response on enter
				let rect = textContainer.getBoundingClientRect();

				// Set both target and current positions to avoid jumps
				mousePosition.x = targetMousePosition.x = (event.clientX - rect.left) / rect.width;
				mousePosition.y = targetMousePosition.y = (event.clientY - rect.top) / rect.height;

				// Hide the info text after user starts interacting
				setTimeout(() => {
					document.querySelector(".info").style.opacity = "0";
				}, 2000);
			}

			function handleMouseLeave() {
				easeFactor = 0.01; // Slow trailing effect when leaving
				// Keep the target at current position to avoid jumps
				targetMousePosition = {...mousePosition};
			}

			// Handle window resize
			window.addEventListener("resize", onWindowResize, false);

			function onWindowResize() {
				// Update camera aspect ratio
				const aspectRatio = window.innerWidth / window.innerHeight;
				camera.left = -1;
				camera.right = 1;
				camera.top = 1 / aspectRatio;
				camera.bottom = -1 / aspectRatio;
				camera.updateProjectionMatrix();

				// Update renderer size
				renderer.setSize(window.innerWidth, window.innerHeight);

				// Recreate the texture for the new window size
				planeMesh.material.uniforms.u_texture.value = createTextTexture("EXPR", "sans-serif", null, "#ffffff", "bold");
			}
		</script>
	</body>
</html>
