"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _VFXPlayer_instances, _VFXPlayer_canvas, _VFXPlayer_renderer, _VFXPlayer_camera, _VFXPlayer_playRequest, _VFXPlayer_pixelRatio, _VFXPlayer_elements, _VFXPlayer_textureLoader, _VFXPlayer_viewport, _VFXPlayer_mouseX, _VFXPlayer_mouseY, _VFXPlayer_isRenderingToCanvas, _VFXPlayer_updateCanvasSize, _VFXPlayer_width, _VFXPlayer_height, _VFXPlayer_resize, _VFXPlayer_mousemove, _VFXPlayer_rerenderTextElement, _VFXPlayer_playLoop, _VFXPlayer_getShader, _VFXPlayer_getGLSLVersion;
Object.defineProperty(exports, "__esModule", { value: true });
exports.VFXPlayer = void 0;
exports.isRectInViewport = isRectInViewport;
exports.checkIntersection = checkIntersection;
exports.parseOverflowOpts = parseOverflowOpts;
exports.parseIntersectionOpts = parseIntersectionOpts;
const THREE = __importStar(require("three"));
const dom_to_canvas_js_1 = __importDefault(require("./dom-to-canvas.js"));
const constants_js_1 = require("./constants.js");
const gif_js_1 = __importDefault(require("./gif.js"));
const rect_js_1 = require("./rect.js");
const gifFor = new Map();
/**
 * @internal
 */
class VFXPlayer {
    constructor(canvas, pixelRatio) {
        _VFXPlayer_instances.add(this);
        _VFXPlayer_canvas.set(this, void 0);
        _VFXPlayer_renderer.set(this, void 0);
        _VFXPlayer_camera.set(this, void 0);
        _VFXPlayer_playRequest.set(this, undefined);
        _VFXPlayer_pixelRatio.set(this, 2);
        _VFXPlayer_elements.set(this, []);
        _VFXPlayer_textureLoader.set(this, new THREE.TextureLoader());
        _VFXPlayer_viewport.set(this, {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
        });
        _VFXPlayer_mouseX.set(this, 0);
        _VFXPlayer_mouseY.set(this, 0);
        _VFXPlayer_isRenderingToCanvas.set(this, new WeakMap());
        _VFXPlayer_resize.set(this, () => __awaiter(this, void 0, void 0, function* () {
            if (typeof window !== "undefined") {
                // Update dom2canvas result.
                // Render elements in viewport first, then render elements outside of the viewport.
                for (const e of __classPrivateFieldGet(this, _VFXPlayer_elements, "f")) {
                    if (e.type === "text" && e.isInViewport) {
                        const rect = e.element.getBoundingClientRect();
                        if (rect.width !== e.width || rect.height !== e.height) {
                            yield __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_rerenderTextElement).call(this, e);
                            e.width = rect.width;
                            e.height = rect.height;
                        }
                    }
                }
                for (const e of __classPrivateFieldGet(this, _VFXPlayer_elements, "f")) {
                    if (e.type === "text" && !e.isInViewport) {
                        const rect = e.element.getBoundingClientRect();
                        if (rect.width !== e.width || rect.height !== e.height) {
                            yield __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_rerenderTextElement).call(this, e);
                            e.width = rect.width;
                            e.height = rect.height;
                        }
                    }
                }
            }
        }));
        _VFXPlayer_mousemove.set(this, (e) => {
            if (typeof window !== "undefined") {
                __classPrivateFieldSet(this, _VFXPlayer_mouseX, e.clientX, "f");
                __classPrivateFieldSet(this, _VFXPlayer_mouseY, window.innerHeight - e.clientY, "f");
            }
        });
        _VFXPlayer_playLoop.set(this, () => {
            var _a;
            const now = Date.now() / 1000;
            __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").clear();
            // This must done every frame because iOS Safari doesn't fire
            // window resize event while the address bar is transforming.
            __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_updateCanvasSize).call(this);
            for (const e of __classPrivateFieldGet(this, _VFXPlayer_elements, "f")) {
                const rect = e.element.getBoundingClientRect();
                const rectHitTest = (0, rect_js_1.growRect)(rect, e.overflow);
                // Check intersection
                const isInViewport = e.isFullScreen || isRectInViewport(__classPrivateFieldGet(this, _VFXPlayer_viewport, "f"), rectHitTest);
                const logicalViewport = (0, rect_js_1.growRect)(__classPrivateFieldGet(this, _VFXPlayer_viewport, "f"), e.intersection.rootMargin);
                const intersection = (0, rect_js_1.getIntersection)(logicalViewport, rect);
                const isInLogicalViewport = e.isFullScreen ||
                    checkIntersection(logicalViewport, rect, intersection, e.intersection.threshold);
                // Update transition timing
                if (!e.isInLogicalViewport && isInLogicalViewport /* out -> in */) {
                    e.enterTime = now;
                    e.leaveTime = Infinity;
                }
                if (e.isInLogicalViewport && !isInLogicalViewport /* in -> out */) {
                    e.leaveTime = now;
                }
                e.isInViewport = isInViewport;
                e.isInLogicalViewport = isInLogicalViewport;
                // Quit if the element has left and the transition has ended
                if (!isInViewport || now - e.leaveTime > e.release) {
                    continue;
                }
                // Update uniforms
                e.uniforms["time"].value = now - e.startTime;
                e.uniforms["enterTime"].value = now - e.enterTime;
                e.uniforms["leaveTime"].value = now - e.leaveTime;
                e.uniforms["resolution"].value.x = rect.width * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"); // TODO: use correct width, height
                e.uniforms["resolution"].value.y = rect.height * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
                e.uniforms["offset"].value.x = rect.left * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
                e.uniforms["offset"].value.y =
                    (window.innerHeight - rect.top - rect.height) *
                        __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
                e.uniforms["mouse"].value.x = __classPrivateFieldGet(this, _VFXPlayer_mouseX, "f") * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
                e.uniforms["mouse"].value.y = __classPrivateFieldGet(this, _VFXPlayer_mouseY, "f") * __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f");
                e.uniforms["intersection"].value = intersection;
                for (const [key, gen] of Object.entries(e.uniformGenerators)) {
                    e.uniforms[key].value = gen();
                }
                // Update GIF / video
                (_a = gifFor.get(e.element)) === null || _a === void 0 ? void 0 : _a.update();
                if (e.type === "video" || e.isGif) {
                    e.uniforms["src"].value.needsUpdate = true;
                }
                // Set viewport
                if (e.isFullScreen) {
                    __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setViewport(0, 0, window.innerWidth, window.innerHeight);
                }
                else {
                    __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setViewport(rect.left - e.overflow.left, window.innerHeight -
                        (rect.top + rect.height) -
                        e.overflow.bottom, rect.width + (e.overflow.left + e.overflow.right), rect.height + (e.overflow.top + e.overflow.bottom));
                }
                // Render to viewport
                __classPrivateFieldGet(this, _VFXPlayer_camera, "f").lookAt(e.scene.position);
                try {
                    __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").render(e.scene, __classPrivateFieldGet(this, _VFXPlayer_camera, "f"));
                }
                catch (e) {
                    console.error(e);
                }
            }
            if (this.isPlaying()) {
                __classPrivateFieldSet(this, _VFXPlayer_playRequest, requestAnimationFrame(__classPrivateFieldGet(this, _VFXPlayer_playLoop, "f")), "f");
            }
        });
        __classPrivateFieldSet(this, _VFXPlayer_canvas, canvas, "f");
        __classPrivateFieldSet(this, _VFXPlayer_renderer, new THREE.WebGLRenderer({
            canvas,
            alpha: true,
        }), "f");
        __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").autoClear = false;
        __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setClearAlpha(0);
        if (typeof window !== "undefined") {
            __classPrivateFieldSet(this, _VFXPlayer_pixelRatio, pixelRatio || window.devicePixelRatio, "f");
            window.addEventListener("resize", __classPrivateFieldGet(this, _VFXPlayer_resize, "f"));
            window.addEventListener("mousemove", __classPrivateFieldGet(this, _VFXPlayer_mousemove, "f"));
        }
        __classPrivateFieldGet(this, _VFXPlayer_resize, "f").call(this);
        __classPrivateFieldSet(this, _VFXPlayer_camera, new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10), "f");
        __classPrivateFieldGet(this, _VFXPlayer_camera, "f").position.set(0, 0, 1);
    }
    destroy() {
        this.stop();
        if (typeof window !== "undefined") {
            window.removeEventListener("resize", __classPrivateFieldGet(this, _VFXPlayer_resize, "f"));
            window.removeEventListener("mousemove", __classPrivateFieldGet(this, _VFXPlayer_mousemove, "f"));
        }
    }
    addElement(element_1) {
        return __awaiter(this, arguments, void 0, function* (element, opts = {}) {
            var _a, _b;
            const shader = __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_getShader).call(this, opts.shader || "uvGradient");
            const glslVersion = __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_getGLSLVersion).call(this, opts.glslVersion, shader);
            const rect = element.getBoundingClientRect();
            const [isFullScreen, overflow] = parseOverflowOpts(opts.overflow);
            const rectHitTest = (0, rect_js_1.growRect)(rect, overflow);
            const intersectionOpts = parseIntersectionOpts(opts.intersection);
            const isInViewport = isFullScreen || isRectInViewport(__classPrivateFieldGet(this, _VFXPlayer_viewport, "f"), rectHitTest);
            const logicalViewport = (0, rect_js_1.growRect)(__classPrivateFieldGet(this, _VFXPlayer_viewport, "f"), intersectionOpts.rootMargin);
            const intersection = (0, rect_js_1.getIntersection)(__classPrivateFieldGet(this, _VFXPlayer_viewport, "f"), rect);
            const isInLogicalViewport = isFullScreen ||
                checkIntersection(logicalViewport, rect, intersection, intersectionOpts.threshold);
            const originalOpacity = element.style.opacity === ""
                ? 1
                : parseFloat(element.style.opacity);
            // Create values for element types
            let texture;
            let type;
            let isGif = false;
            if (element instanceof HTMLImageElement) {
                type = "img";
                isGif = !!element.src.match(/\.gif/i);
                if (isGif) {
                    const gif = yield gif_js_1.default.create(element.src, __classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"));
                    gifFor.set(element, gif);
                    texture = new THREE.Texture(gif.getCanvas());
                }
                else {
                    texture = __classPrivateFieldGet(this, _VFXPlayer_textureLoader, "f").load(element.src);
                }
            }
            else if (element instanceof HTMLVideoElement) {
                texture = new THREE.VideoTexture(element);
                type = "video";
            }
            else if (element instanceof HTMLCanvasElement) {
                texture = new THREE.CanvasTexture(element);
                type = "canvas";
            }
            else {
                const canvas = yield (0, dom_to_canvas_js_1.default)(element, originalOpacity);
                texture = new THREE.CanvasTexture(canvas);
                type = "text";
            }
            const [wrapS, wrapT] = parseWrap(opts.wrap);
            texture.wrapS = wrapS;
            texture.wrapT = wrapT;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.format = THREE.RGBAFormat;
            texture.needsUpdate = true;
            // Hide original element
            if (opts.overlay === true) {
                /* Overlay mode. Do not hide the element */
            }
            else if (typeof opts.overlay === "number") {
                element.style.setProperty("opacity", opts.overlay.toString());
            }
            else {
                const opacity = type === "video" ? "0.0001" : "0"; // don't hide video element completely to prevent jank frames
                element.style.setProperty("opacity", opacity.toString());
            }
            const uniforms = {
                src: { value: texture },
                resolution: {
                    value: new THREE.Vector2(),
                },
                offset: { value: new THREE.Vector2() },
                time: { value: 0.0 },
                enterTime: { value: -1.0 },
                leaveTime: { value: -1.0 },
                mouse: { value: new THREE.Vector2() },
                intersection: { value: intersection },
            };
            const uniformGenerators = {};
            if (opts.uniforms !== undefined) {
                const keys = Object.keys(opts.uniforms);
                for (const key of keys) {
                    const value = opts.uniforms[key];
                    if (typeof value === "function") {
                        uniforms[key] = {
                            value: value(),
                        };
                        uniformGenerators[key] = value;
                    }
                    else {
                        uniforms[key] = { value };
                    }
                }
            }
            const scene = new THREE.Scene();
            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.ShaderMaterial({
                vertexShader: constants_js_1.DEFAULT_VERTEX_SHADER,
                fragmentShader: shader,
                transparent: true,
                uniforms,
                glslVersion,
            });
            scene.add(new THREE.Mesh(geometry, material));
            const now = Date.now() / 1000;
            const elem = {
                type,
                element,
                isInViewport,
                isInLogicalViewport,
                width: rect.width,
                height: rect.height,
                scene,
                uniforms,
                uniformGenerators,
                startTime: now,
                enterTime: isInLogicalViewport ? now : -Infinity,
                leaveTime: isInLogicalViewport ? Infinity : -Infinity,
                release: (_a = opts.release) !== null && _a !== void 0 ? _a : Infinity,
                isGif,
                isFullScreen,
                overflow,
                intersection: intersectionOpts,
                originalOpacity,
                zIndex: (_b = opts.zIndex) !== null && _b !== void 0 ? _b : 0,
            };
            // Insert element and sort elements by z-index.
            // Array.prototype.sort is stable sort, so the elements with same z
            // will be rendered by the order they are added to VFX.
            __classPrivateFieldGet(this, _VFXPlayer_elements, "f").push(elem);
            __classPrivateFieldGet(this, _VFXPlayer_elements, "f").sort((a, b) => a.zIndex - b.zIndex);
        });
    }
    removeElement(element) {
        const i = __classPrivateFieldGet(this, _VFXPlayer_elements, "f").findIndex((e) => e.element === element);
        if (i !== -1) {
            const e = __classPrivateFieldGet(this, _VFXPlayer_elements, "f").splice(i, 1)[0];
            // Recover the original state
            element.style.setProperty("opacity", e.originalOpacity.toString());
        }
    }
    updateTextElement(element) {
        const i = __classPrivateFieldGet(this, _VFXPlayer_elements, "f").findIndex((e) => e.element === element);
        if (i !== -1) {
            return __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_rerenderTextElement).call(this, __classPrivateFieldGet(this, _VFXPlayer_elements, "f")[i]);
        }
        // Do nothing if the element is not found
        // This happens when addElement is still processing
        return Promise.resolve();
    }
    updateCanvasElement(element) {
        const e = __classPrivateFieldGet(this, _VFXPlayer_elements, "f").find((e) => e.element === element);
        if (e) {
            const oldTexture = e.uniforms["src"].value;
            const texture = new THREE.CanvasTexture(element);
            texture.wrapS = oldTexture.wrapS;
            texture.wrapT = oldTexture.wrapT;
            e.uniforms["src"].value = texture;
            oldTexture.dispose();
        }
    }
    isPlaying() {
        return __classPrivateFieldGet(this, _VFXPlayer_playRequest, "f") !== undefined;
    }
    play() {
        if (!this.isPlaying()) {
            __classPrivateFieldSet(this, _VFXPlayer_playRequest, requestAnimationFrame(__classPrivateFieldGet(this, _VFXPlayer_playLoop, "f")), "f");
        }
    }
    stop() {
        if (__classPrivateFieldGet(this, _VFXPlayer_playRequest, "f") !== undefined) {
            cancelAnimationFrame(__classPrivateFieldGet(this, _VFXPlayer_playRequest, "f"));
            __classPrivateFieldSet(this, _VFXPlayer_playRequest, undefined, "f");
        }
    }
}
exports.VFXPlayer = VFXPlayer;
_VFXPlayer_canvas = new WeakMap(), _VFXPlayer_renderer = new WeakMap(), _VFXPlayer_camera = new WeakMap(), _VFXPlayer_playRequest = new WeakMap(), _VFXPlayer_pixelRatio = new WeakMap(), _VFXPlayer_elements = new WeakMap(), _VFXPlayer_textureLoader = new WeakMap(), _VFXPlayer_viewport = new WeakMap(), _VFXPlayer_mouseX = new WeakMap(), _VFXPlayer_mouseY = new WeakMap(), _VFXPlayer_isRenderingToCanvas = new WeakMap(), _VFXPlayer_resize = new WeakMap(), _VFXPlayer_mousemove = new WeakMap(), _VFXPlayer_playLoop = new WeakMap(), _VFXPlayer_instances = new WeakSet(), _VFXPlayer_updateCanvasSize = function _VFXPlayer_updateCanvasSize() {
    if (typeof window !== "undefined") {
        const w = window.innerWidth;
        const h = window.innerHeight;
        if (w !== __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_width).call(this) || h !== __classPrivateFieldGet(this, _VFXPlayer_instances, "m", _VFXPlayer_height).call(this)) {
            __classPrivateFieldGet(this, _VFXPlayer_canvas, "f").width = w;
            __classPrivateFieldGet(this, _VFXPlayer_canvas, "f").height = h;
            __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setSize(w, h);
            __classPrivateFieldGet(this, _VFXPlayer_renderer, "f").setPixelRatio(__classPrivateFieldGet(this, _VFXPlayer_pixelRatio, "f"));
            __classPrivateFieldSet(this, _VFXPlayer_viewport, {
                top: 0,
                left: 0,
                right: w,
                bottom: h,
            }, "f");
        }
    }
}, _VFXPlayer_width = function _VFXPlayer_width() {
    return __classPrivateFieldGet(this, _VFXPlayer_viewport, "f").right - __classPrivateFieldGet(this, _VFXPlayer_viewport, "f").left;
}, _VFXPlayer_height = function _VFXPlayer_height() {
    return __classPrivateFieldGet(this, _VFXPlayer_viewport, "f").bottom - __classPrivateFieldGet(this, _VFXPlayer_viewport, "f").top;
}, _VFXPlayer_rerenderTextElement = function _VFXPlayer_rerenderTextElement(e) {
    return __awaiter(this, void 0, void 0, function* () {
        if (__classPrivateFieldGet(this, _VFXPlayer_isRenderingToCanvas, "f").get(e.element)) {
            return;
        }
        __classPrivateFieldGet(this, _VFXPlayer_isRenderingToCanvas, "f").set(e.element, true);
        try {
            const oldTexture = e.uniforms["src"].value;
            const oldCanvas = oldTexture.image;
            const canvas = yield (0, dom_to_canvas_js_1.default)(e.element, e.originalOpacity, oldCanvas);
            if (canvas.width === 0 || canvas.width === 0) {
                throw "omg";
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = oldTexture.wrapS;
            texture.wrapT = oldTexture.wrapT;
            e.uniforms["src"].value = texture;
            oldTexture.dispose();
        }
        catch (e) {
            console.error(e);
        }
        __classPrivateFieldGet(this, _VFXPlayer_isRenderingToCanvas, "f").set(e.element, false);
    });
}, _VFXPlayer_getShader = function _VFXPlayer_getShader(shaderNameOrCode) {
    if (shaderNameOrCode in constants_js_1.shaders) {
        return constants_js_1.shaders[shaderNameOrCode];
    }
    else {
        return shaderNameOrCode; // Assume that the given string is a valid shader code
    }
}, _VFXPlayer_getGLSLVersion = function _VFXPlayer_getGLSLVersion(opt, shader) {
    if (opt) {
        return opt;
    }
    if (shader.includes("out vec4")) {
        return "300 es";
    }
    if (shader.includes("gl_FragColor")) {
        return "100";
    }
    throw `VFX-JS error: Cannot detect GLSL version of the shader.\n\nOriginal shader:\n${shader}`;
};
/**
 * Returns if the given rects intersect.
 * It returns true when the rects are adjacent (= intersection ratio is 0).
 */
function isRectInViewport(viewport, rect) {
    return (rect.left <= viewport.right &&
        rect.right >= viewport.left &&
        rect.top <= viewport.bottom &&
        rect.bottom >= viewport.top);
}
function checkIntersection(viewport, rect, intersection, threshold) {
    if (threshold === 0) {
        // if threshold === 0, consider adjacent rects to be intersecting.
        return isRectInViewport(viewport, rect);
    }
    else {
        return intersection >= threshold;
    }
}
function parseOverflowOpts(overflow) {
    if (overflow === true) {
        return [true, rect_js_1.RECT_ZERO];
    }
    if (overflow === undefined) {
        return [false, rect_js_1.RECT_ZERO];
    }
    return [false, (0, rect_js_1.createRect)(overflow)];
}
function parseIntersectionOpts(intersectionOpts) {
    var _a, _b;
    const threshold = (_a = intersectionOpts === null || intersectionOpts === void 0 ? void 0 : intersectionOpts.threshold) !== null && _a !== void 0 ? _a : 0;
    const rootMargin = (0, rect_js_1.createRect)((_b = intersectionOpts === null || intersectionOpts === void 0 ? void 0 : intersectionOpts.rootMargin) !== null && _b !== void 0 ? _b : 0);
    return {
        threshold,
        rootMargin,
    };
}
function parseWrapSingle(wrapOpt) {
    if (wrapOpt === "repeat") {
        return THREE.RepeatWrapping;
    }
    else if (wrapOpt === "mirror") {
        return THREE.MirroredRepeatWrapping;
    }
    else {
        return THREE.ClampToEdgeWrapping;
    }
}
function parseWrap(wrapOpt) {
    if (!wrapOpt) {
        return [THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping];
    }
    if (Array.isArray(wrapOpt)) {
        return [parseWrapSingle(wrapOpt[0]), parseWrapSingle(wrapOpt[1])];
    }
    else {
        const w = parseWrapSingle(wrapOpt);
        return [w, w];
    }
}
//# sourceMappingURL=vfx-player.js.map