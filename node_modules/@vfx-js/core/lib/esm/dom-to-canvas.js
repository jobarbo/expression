var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Convert HTML string to valid XML.
 * @internal
 */
const convertHtmlToXml = (html) => {
    const doc = document.implementation.createHTMLDocument("test");
    const range = doc.createRange();
    range.selectNodeContents(doc.documentElement);
    range.deleteContents();
    const h = document.createElement("head");
    doc.documentElement.appendChild(h);
    doc.documentElement.appendChild(range.createContextualFragment(html));
    doc.documentElement.setAttribute("xmlns", doc.documentElement.namespaceURI);
    // Get well-formed markup
    const wfHtml = new XMLSerializer().serializeToString(doc);
    return wfHtml.replace(/<!DOCTYPE html>/, "");
};
// Clone DOM node.
function cloneNode(node) {
    return node.cloneNode(true);
}
/**
 * Render element content to canvas and return it.
 * @internal
 */
export default function getCanvasFromElement(element, originalOpacity, oldCanvas) {
    return __awaiter(this, void 0, void 0, function* () {
        const rect = element.getBoundingClientRect();
        const ratio = window.devicePixelRatio;
        const width = rect.width * ratio;
        const height = rect.height * ratio;
        const canvas = oldCanvas && oldCanvas.width === width && oldCanvas.height === height
            ? oldCanvas
            : new OffscreenCanvas(width, height);
        // Clone element with styles in text attribute
        // to apply styles in SVG
        const newElement = cloneNode(element);
        yield syncStylesOfTree(element, newElement);
        newElement.style.setProperty("opacity", originalOpacity.toString());
        // Remove margins of the root element
        newElement.style.setProperty("margin", "0px");
        // Create SVG string
        const html = newElement.outerHTML;
        const xml = convertHtmlToXml(html);
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">` +
            `<foreignObject width="100%" height="100%">${xml}</foreignObject></svg>`;
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const ctx = canvas.getContext("2d");
                if (ctx === null) {
                    return reject();
                }
                ctx.clearRect(0, 0, width, height);
                ctx.scale(ratio, ratio);
                ctx.drawImage(img, 0, 0, width, height);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                resolve(canvas);
            };
            img.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
        });
    });
}
function syncStylesOfTree(el1, el2) {
    return __awaiter(this, void 0, void 0, function* () {
        // Sync CSS styles
        const styles = window.getComputedStyle(el1);
        Array.from(styles).forEach((key) => {
            el2.style.setProperty(key, styles.getPropertyValue(key), styles.getPropertyPriority(key));
        });
        // Reflect input value to HTML attributes
        if (el2.tagName === "INPUT") {
            el2.setAttribute("value", el2.value);
        }
        else if (el2.tagName === "TEXTAREA") {
            el2.innerHTML = el2.value;
        }
        else if (el2.tagName === "IMG") {
            // SVG forignObject does not accept external file,
            // so we have to convert the src URL to Data URL
            el2.src = yield toObjectUrl(el1.src);
        }
        for (let i = 0; i < el1.children.length; i++) {
            const c1 = el1.children[i];
            const c2 = el2.children[i];
            yield syncStylesOfTree(c1, c2);
        }
    });
}
// ref. https://stackoverflow.com/questions/44698967/
function toObjectUrl(url) {
    return __awaiter(this, void 0, void 0, function* () {
        const blob = yield fetch(url).then((response) => response.blob());
        return new Promise((callback) => {
            const reader = new FileReader();
            reader.onload = function () {
                callback(this.result);
            };
            reader.readAsDataURL(blob);
        });
    });
}
//# sourceMappingURL=dom-to-canvas.js.map